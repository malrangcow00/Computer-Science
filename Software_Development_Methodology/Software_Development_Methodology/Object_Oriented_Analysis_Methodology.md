### 객체 지향

객체 지향은 실세계의 개체를 속성과 메서드가 결합한 형태의 객체로 표현하는 기법

### 객체 지향 구성요소

<table>
   <tr>
      <th>구성요소</th>
      <th>설명</th>
   </tr>
   <tr>
      <td>클래스<br>
         (Class)
      </td>
      <td>- 특정 객체 내에 있는 변수와 메서드를 정의하는 일종의 틀<br>
         - 객체 지향 프로그래밍에서 데이터를 추상화하는 단위<br>
         - 하나 이상의 유사한 객체들을 묶어서 하나의 공통된 특성을 표현<br>
         - 속성은 변수의 형태로, 행위는 메서드 형태로 선언
      </td>
   </tr>
   <tr>
      <td>객체<br>(Object)</td>
      <td>- 물리적, 추상적으로 자신과 다른 것을 식별 가능한 대상<br>
         - 클래스에서 정의한 것을 토대로 메모리에 할당됨<br>
         - 객체마다 각각의 상태와 식별성을 가짐
      </td>
   </tr>
   <tr>
      <td>메서드<br>
         (Method)
      </td>
      <td>- 클래스로부터 생성된 객체를 사용하는 방법<br>
         - 객체가 메시지를 받아 실행해야 할 객체의 구체적인 연산<br>
         - 전통적 시스템의 함수(Function) 또는 프로시저(Procedure)에 해당하는 연산 기능
      </td>
   </tr>
   <tr>
      <td>메시지<br>
         (Message)
      </td>
      <td>- 객체 간 상호 작용을 하기 위한 수단<br>
         - 객체에게 어떤 행위를 하도록 지시하는 방법<br>
         - 객체 간의 상호 작용은 메시지를 통해 이루어진다<br>
         - 메시지는 객체에서 객체로 전달된다
      </td>
   </tr>
   <tr>
      <td>인스턴스<br>
         (Instance)
      </td>
      <td>- 객체 지향 기법에서 클래스를 통해 만든 실제의 실형 객체<br>
         - 클래스에 속한 각각의 객체<br>
         - 실제로 메모리상에 할당
      </td>
   </tr>
   <tr>
      <td>속성<br>(Property)</td>
      <td>- 한 클래스 내에 속한 객체들이 가지고 있는 데이터 값들을 단위별로 정의<br>
         - 성질, 분류, 식별, 수량, 현재 상태 등에 대한 표현 값
      </td>
   </tr>
</table>

### 객체 지향 기법

<table>
   <tr>
      <th>기법</th>
      <th>설명</th>
   </tr>
   <tr>
      <td>캡슐화<br>
         (Encapsulation)
      </td>
      <td>
         - 객체의 속성(데이터)과 행위(함수)를 하나로 묶는다<br>
         - 외부와 경계를 만들어 결합도가 낮아지고 재사용이 용이<br>
         - 객체의 내부 구현을 외부로부터 감추고 필요한 인터페이스만을 밖으로 드러내 통해 객체와 상호작용한다.<br>
         - 정보 은닉에 유리하다<br>
         - 변경 발생 시 오류의 파급 효과가 적다
      </td>
   </tr>
   <tr>
      <td>상속성<br>
         (Inheritance)
      </td>
      <td>- 상위 클래스의 속성과 메서드를 하위 클래스에서 재정의 없이 물려받아 사용하는 기법
      </td>
   </tr>
   <tr>
      <td>다형성<br>
         (Polymorphism)
      </td>
      <td>- 하나의 메시지에 대해 각 개체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력<br>
         - 상속받은 여러 개의 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용될 수 있는 성질<br>
         - 같은 이름의 메서드를 호출하더라도 다른 기능을 한다<br>
         - <a href="Polymorphism/Introduction.md">오버로딩, 오버라이딩</a>이 대표적인 방식<br>
         - 같은 이름의 메서드가 서로 다른 기능을 하는 것<br>
      </td>
   </tr>
   <tr>
      <td>추상화<br>
         (Abstraction)
      </td>
      <td>공통 성질을 추출하여 추상 클래스를 설정하는 기법</td>
   </tr>
   <tr>
      <td>정보 은닉<br>(Information Hiding)</td>
      <td>- 코드 내부 데이터와 메서드를 숨기고 공개 인터페이스를 통해서만 접근이 가능하도록 하는 코드 보안 기술<br>
         - 필요하지 않은 정보는 접근할 수 없도록 하여 한 모듈 또는 하부 시스템이 다른 모듈의 구현에 영향을 받지 않게 설계됨<br>
         - 모듈 사이의 독립성을 유지하는 데 도움을 준다
      </td>
   </tr>
   <tr>
      <td>관계성<br>(Relationship)</td>
      <td>- 두 개 이상의 엔터티 형에서 데이터를 참조하는 관계를 나타내는 기법<br>
         - <a href="Relationship/Introduction.md">연관화, 분류화, 집단화, 일반화, 특수화</a>가 있다
      </td>
   </tr>
</table>

### 객체 지향 설계 원칙(SOLID)
- 단일 책임의 원칙 (SRP, Single Responsibility Principle)
  - 하나의 클래스는 하나의 목적을 위해서 생성되며, 클래스가 제공하는 모든 서비스는 하나의 책임을 수행하는 데 집중되어 있어야 한다는 원칙
  - 객체 지향 프로그래밍의 5원칙 중 나머지 4원칙의 기초 원칙
- 개방 폐쇄의 원칙 (OCP, Open Closed Principle)
  - 소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다는 원칙
  - 기존의 코드를 변경하지 않고 새로운 기능을 추가할 수 있도록 설계해야 한다
- 리스코프 치환의 원칙 (LSP, Liskov Substitution Principle)
  - 서브 타입(상속받은 하위 클래스)은 언제나 기반 타입(상위 클래스)으로 교체할 수 있어야 한다는 원칙
  - 상속 관계에서 부모 클래스의 인스턴스 대신에 자식 클래스의 인스턴스로 대체해도 프로그램의 의미는 변하지 않아야 한다
- 인터페이스 분리의 원칙 (ISP, Interface Segregation Principle)
  - 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다
  - 객체 설계 시 특정 기능에 대한 인터페이스는 그 기능과 상관없는 부분이 변해도 영향을 받지 않아야 한다
  - 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다
- 의존성 역전의 원칙 (DIP, Dependency Inversion Principle)
  - 객체에서 어떤 클래스를 참조해서 사용하는 경우, 그 클래스를 직접 참조하는 것이 아니라 그 대상의 상위 요소인 추상 클래스나 인터페이스로 참조해야한다
  - 고수준 모듈은 저수준 모듈에 의존해서는 안 된다
  - 둘 다 추상화에 의존해야 한다
  - 추상화는 세부 사항에 의존해서는 안 된다
  - 세부 사항은 추상화에 의존해야 한다

### 객체 지향 분석 (OOA, Object-Oriented Analysis)
객체 지향 분석은 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스(객체), 속성과 연산, 관계를 정의하여 모델링하는 기법이다.

### 객체 지향 분석 방법론 종류
<table>
<tr>
<th>방법론</th>
<th>만든 이</th>
<th>설명</th>
</tr>
<tr>
<td>OOSE<br>
(Object Oriented Software Engineering)</td>
<td>야콥슨<br>
(Jacobson)</td>
<td>- 유스케이스에 의한 접근 방법으로 유스케이스를 모든 모델의 근간으로 활용하는 방법론<br>
- 분석, 설계, 구현 단계로 구성<br>
- 기능적 요구사항 중심의 시스템</td></tr>
<tr><td><a href="">OMT<br>(Object Modeling Technology)</a></td>
<td>럼바우<br>
(Rumbaugh)</td>
<td>- 그래픽 표기법을 이용하여 소프트웨어 구성요소를 모델링하는 방법론<br>
- 분석 절차는 객체 모델링 &rarr; 동적 모델링 &rarr; 기능 모델링 순서로 진행</td>
</tr>
<tr>
<td>OOD<br>
(Object Oriented Design)</td>
<td>부치<br>
(Booch)</td>
<td>- 설계 문서화를 강조하여 다이어그램 중심으로 개발하는 방법론<br>
- 분석과 설계의 분리가 불가능<br>
- 분석하는 데 이용된 객체 모델의 설계 시 적용</td>
</tr>
</table>

<table>
<tr>
<th>방법론</th>
<th>설명</th>
</tr>
<tr>
<td>
코드-요든<br>
(Coad-Yourdon)<br>
방법론</td>
<td>E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체 식별, 구조 식별, 주체 정의, 속성 및 관계 정의, 서비스 정의 등의 과정으로 구성되는 객체 지향 분석 방법</td>
</tr>
<tr>
<td>워프-브록<br>(Wirfs-Brock)<br>방법론</td>
<td>분석과 설계 간의 구분이 없고 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행하는 분석 방법</td></tr>
</table>

